## effectiveJavaSample
Effective Java Sample  
学习高效Java书中的示例代码
## 文章目录
* 译者序
* 序
* 前言
* 致谢
### 第1章 引言
### 第2章 创建和销毁对象
* 第1条：考虑用静态工厂方法代替构造器
* 第2条：遇到多个构造器参数时要考虑用构建器
* 第3条：用私有构造器或者枚举类型强化Singleton属性
* 第4条：通过私有构造器强化不可实例化的能力
* 第5条：避免创建不必要的对象
* 第6条：消除过期的对象引用
* 第7条：避免使用终结方法
### 第3章 对于所有对象都通用的方法
* 第8条：覆盖equals时请遵守通用约定
* 第9条：覆盖equals时总要覆盖hashCode
* 第10条：始终要覆盖toString
* 第11条：谨慎地覆盖clone
* 第12条：考虑实现Comparable接口
### 第4章 类和接口
* 第13条：使类和成员的可访问性最小化
* 第14条：在公有类中使用访问方法而非公有域
* 第15条：使可变性最小化
* 第16条：复合优先于继承
* 第17条：要么为继承而设计，并提供文档说明，要么就禁止继承
* 第18条：接口优于抽象类
* 第19条：接口只用于定义类型
* 第20条：类层次优于标签类
* 第21条：用函数对象表示策略
* 第22条：优先考虑静态成员类
### 第5章 泛型
* 第23条：请不要在新代码中使用原生态类型
* 第24条：消除非受检警告
* 第25条：列表优先于数组
* 第26条：优先考虑泛型
* 第27条：优先考虑泛型方法
* 第28条：利用有限制通配符来提升API的灵活性
* 第29条：优先考虑类型安全的异构容器
### 第6章 枚举和注解
* 第30条：用enum代替int常量
* 第31条：用实例域代替序数
* 第32条：用EnumSet代替位域
* 第33条：用EnumMap代替序数索引
* 第34条：用接口模拟可伸缩的枚举
* 第35条：注解优先于命名模式
* 第36条：坚持使用Override注解
* 第37条：用标记接口定义类型
### 第7章 方法
* 第38条：检查参数的有效性
* 第39条：必要时进行保护性拷贝
* 第40条：谨慎设计方法签名
* 第41条：慎用重载
* 第42条：慎用可变参数
* 第43条：返回零长度的数组或者集合，而不是：null
* 第44条：为所有导出的API元素编写文档注释
### 第8章 通用程序设计
* 第45条：将局部变量的作用域最小化
* 第46条：for-each循环优先于传统的for循环
* 第47条：了解和使用类库
* 第48条：如果需要精确的答案，请避免使用float和double
* 第49条：基本类型优先于装箱基本类型
* 第50条：如果其他类型更适合，则尽量避免使用字符串
* 第51条：当心字符串连接的性能
* 第52条：通过接口引用对象
* 第53条：接口优先于反射机制
* 第54条：谨慎地使用本地方法
* 第55条：谨慎地进行优化
* 第56条：遵守普遍接受的命名惯例
### 第9章 异常
* 第57条：只针对异常的情况才使用异常
* 第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常
* 第59条：避免不必要地使用受检的异常
* 第60条：优先使用标准的异常
* 第61条：抛出与抽象相对应的异常
* 第62条：每个方法抛出的异常都要有文档
* 第63条：在细节消息中包含能捕获失败的信息
* 第64条：努力使失败保持原子性
* 第65条：不要忽略异常
### 第10章 并发
* 第66条：同步访问共享的可变数据
* 第67条：避免过度同步
* 第68条：executor和task优先干线程
* 第69条：并发工具优先于wait和notify
* 第70条：线程安全性的文档化
* 第71条：慎用延迟初始化
* 第72条：不要依赖于线程调度器
* 第73条：避免使用线程组
### 第11章 序列化
* 第74条：谨慎地实现Serializable接口
* 第75条：考虑使用自定义的序列化形式
* 第76条：保护性地编写readObject方法
* 第77条：对于实例控制，枚举类型优先于readResolve
* 第78条：考虑用序列化代理代替序列化实例
* 附录 第1版与第2版条目对照
* 中英文术语对照
* 参考文献